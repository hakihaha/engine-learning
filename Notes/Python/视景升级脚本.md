## 设计思路
1. U盘为储存介质，分别有视景软件包和视景升级脚本。
2. 视景脚本包括以下功能。
	1. 片量配置选项的拷贝和对比。
	2. 全量配置的拷贝和对比
	3. 文件的迁移和文件的集成化拷贝
	4. 文件日志与动态显示功能。
## 片量配置选项的拷贝和对比
### 读取相应数据
1. 首先确定的获取相应数据(如ClientScreenWidth，ClientScreenHeight，ClientScreenScale，MaxTickRates)。
2. 确定配件文件的目录：如r'H:\V1.0.007\FFS_IGRES\ProjectConfig.json'
3. 确定用的方法：with open(projectConfig_path,'r')as file:
4. 代码如下，定义了一个读取文件相应字段，并将字段输出的方法
```
def read_ProjectConfig():  
    projectConfig_path = r'H:\V1.0.007\FFS_IGRES\ProjectConfig.json'  
    try:  
        with open(projectConfig_path,'r')as file:  
            projectConfig_data = json.load(file)  
            client_screen_width = projectConfig_data.get("ClientScreenWidth", None)#如果该键没有值就返回None  
            client_screen_height = projectConfig_data.get("ClientScreenHeight", None)  
            client_screen_scale = projectConfig_data.get("ClientScreenScale", None)  
            max_tick_rates = projectConfig_data.get("MaxTickRates", None)  
            IPTSetting = projectConfig_data.get("IPTSetting",{})#嵌套的字典方式  
            #en_able = IPTSetting.get("enable",None)#实验下子字典里面取值方法  
            filesystems = projectConfig_data.get("filesystems",{})  
            View_point = projectConfig_data.get("Viewpoint",{})  
  
        #打印读取的值  
            # print(f"ClientScreenWidth: {client_screen_width}")  
            # print(f"ClientScreenHeight: {client_screen_height}") 
            # print(f"ClientScreenScale: {client_screen_scale}")            
            # print(f"MaxTickRates: {max_tick_rates}")          
		 return {  
                "ClientScreenWidth": client_screen_width,  
                "ClientScreenHeight": client_screen_height,  
                "ClientScreenScale": client_screen_scale,  
                "MaxTickRates": max_tick_rates,  
                "IPTSetting":IPTSetting,  
                #"enable":en_able  
                "filesystems":filesystems,  
                "Viewpoint":View_point,  
  
            }  
  
    except FileNotFoundError:  
        print(f"错误：文件{projectConfig_path}不存在")  
    except json.JSONDecodeError:  
        print("错误：json文件格式错误，或者文件损坏")  
    except Exception as e:  
        print(f'读取配置时候出现错误：{str(e)}')	
```
5. 定义主函数 def main()
```
def main():  
    projectConfig_data=read_ProjectConfig()  
	print(projectConfig_data)
```
6. 输出即可
### 获取片量配置数据
- 如上所示： projectConfig_data=read_ProjectConfig() 
### 将获取的片量文件，存为新的json文件
1. 从哪拿到数据，数据存放在哪
	1. 数据： data=projectConfig_data=read_ProjectConfig() 
	2. 放在哪：如果没有就自己创建一个文件
2. 写函数，导入数据。
3. 具体实现代码
```
def save_to_json(data,output_path):  
    try:  
        directory = os.path.dirname(output_path)  
        if not os.path.exists(directory):  
            os.makedirs(directory)   #如果没有就自动创建  
        with open(output_path,'w')as file:  
            json.dump(data,file,indent=4)#写入json格式的数据导文件  
        print(f"数据已经写入到{output_path}")  
    except Exception as e:  
        print(f"写入 JSON 文件时出错: {str(e)}")  
```
5. 写入主函数 def maain()
```
def main():
	original_config_path = r'H:\V1.0.007\ProjectConfig.json'  # 第二级目录才有权限 
    projectConfig_data=read_ProjectConfig()  
	#print(projectConfig_data)
	if projectConfig_data:
		save_to_json(projectConfig_data, original_config_path)

```
### 遍历对比配置项并更改
1. 新的数据在哪，对比的旧配置在哪
	1. 新的数据是：需要新配置的文件如(new_config_path = r'D:\UGit\FFS_Product\FFS_IGRES\ProjectConfig.json')
	2. 旧数据：获取到的片量文件，存为新的json文件，如(original_config_path = r'H:\V1.0.007\ProjectConfig.json'  # 第二级目录才有权限)
2. 怎么对比，需要用函数读取，然后对比。
	1. 实际代码
```
	def read_config(config_path):  
    try:  
        with open(config_path, 'r') as file:  
            return json.load(file)  
    except FileNotFoundError:  
        print(f"错误：文件 {config_path} 不存在")  
    except json.JSONDecodeError:  
        print("错误：json文件格式错误，或者文件损坏")  
    except Exception as e:  
        print(f'读取配置时出现错误：{str(e)}')  
    return {}  	  
```
3. 将读取数据引用并对比
	1. 引用数据（放在主函数里面）；
```
#原数据
original_config_path = r'H:\V1.0.007\ProjectConfig.json'  # 第二级目录才有权限
original_data = read_config(original_config_path)
#新数据
new_config_path = r'D:\UGit\FFS_Product\FFS_IGRES\ProjectConfig.json'
new_data = read_config(new_config_path)
```
	2. 对比数据：
		1. 具体函数代码（使用带原数据参数，和新数据的遍历）
```
def compare_and_update_configs(original_data, new_data):  
    #如果新的配置中没有该键位，或者该键的值与原始配置不一致，就修改  
    for key,original_value in original_data.items():  
        if key not in new_data or new_data[key] != original_value:  
            print(f"修改{key}的值：从{new_data.get(key)}改为{original_value}")  
            new_data[key] = original_value  
    return new_data
```
	 3. 相对比的改完之后的数据储存
```
updated_data = compare_and_update_configs(original_data, new_data)
#借用之前的储存函数
def save_to_json(data,output_path):  
    try:  
        directory = os.path.dirname(output_path)  
        if not os.path.exists(directory):  
            os.makedirs(directory)   #如果没有就自动创建  
        with open(output_path,'w')as file:  
            json.dump(data,file,indent=4)#写入json格式的数据导文件  
        print(f"数据已经写入到{output_path}")  
    except Exception as e:  
        print(f"写入 JSON 文件时出错: {str(e)}")  
def main():
#保存新的文件       
save_to_json(updated_data,new_config_path)
```
	 3. 主函数代码实现
```
def main():  
    original_config_path = r'H:\V1.0.007\ProjectConfig.json'  # 第二级目录才有权限  
    new_config_path = r'D:\UGit\FFS_Product\FFS_IGRES\ProjectConfig.json'   
    original_data = read_config(original_config_path)  
    new_data = read_config(new_config_path)  
    projectConfig_data=read_ProjectConfig()  
    if projectConfig_data:  
        # 比对并更新新配置文件中的键值  
        updated_data = compare_and_update_configs(original_data, new_data)  
        #原始数据榨取  
        save_to_json(projectConfig_data, original_config_path)  
        # 保存修改后的新配置文件  
        save_to_json(updated_data,new_config_path)
```

## 全量配置的拷贝和对比
1. 从哪里拿原始配置文件：config_path
	1. onfig_path =r'D:\UGit\FFS_Product\FFS_IGRES\ProjectConfig.json'#配置路径
2. 原始文件放在哪（为存放的原始配置文件呢建个文件夹）：backup_folder
```
if not os.path.exists(backup_folder):  
    os.makedirs(backup_folder)  
  
#获取文件名和扩展名  
file_name =os.path.basename(config_path)  
backup_file_name = f"{file_name}"  
#备份文件路径  
backup_file_path = os.path.join(backup_folder, backup_file_name)
```
3. 拷贝文件
```
shutil.copy(config_path, backup_file_path)
```
4. 完整代码
