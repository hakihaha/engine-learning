#### 一、入口main函数

﻿

00:00

﻿

##### 1. main函数参数传递

﻿

00:15

﻿

- ![](https://thumbnail0.baidupcs.com/thumbnail/5c1514eacs9329d74329bdbbe4a29d4b?chkbd=0&chkv=0&dp-callid=0&dp-logid=3919679731685168496&expires=8h&fid=1653526243-250528-740135127427402&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-pfBvvp0WXQk%2FCU35CsB%2FJbfKiTs%3D&size=c1080_u1080&time=1766300400&vuk=1653526243)
- 参数作用：用于接收外部程序调用时传递的命令行参数，是C++程序与其他程序交互的简洁方案
- 应用场景：如音视频编解码项目中批量处理时参数传递，相比数据库/网络/文件方式更直接
- 两种形式：
    - int main()：无参数版本
    - int main(int argc, char* argv[])：带参数版本

###### 1）argc

﻿

01:15

﻿

- ![](https://thumbnail0.baidupcs.com/thumbnail/65975ae9bjab4633c5e3569e374d46e4?chkbd=0&chkv=0&dp-callid=0&dp-logid=3919679889447904324&expires=8h&fid=1653526243-250528-382866113366382&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-mw6qYPA%2Fuq5K3lZhWf5JK09cai0%3D&size=c1080_u1080&time=1766300400&vuk=1653526243)
- 参数含义：统计命令行参数的总个数（argument count）
- 计数规则：
    - 程序名称本身计为第1个参数（索引0）
    - 用户实际传递的参数从索引1开始计数
    - 示例：执行./testmain debug info时，argc=3

###### 2）argv

﻿

02:08

﻿

- ![](https://thumbnail0.baidupcs.com/thumbnail/f848919e5rb6cc6eedb162e8e3d5d65d?chkbd=0&chkv=0&dp-callid=0&dp-logid=3919679980544178033&expires=8h&fid=1653526243-250528-138474359269739&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-bpSQTKEfCzDTsLuDLKPTToBbBMQ%3D&size=c1080_u1080&time=1766300400&vuk=1653526243)
- 参数类型：字符指针数组（char* argv[]），存储多个以空格分隔的参数字符串

﻿

05:11

﻿

![](https://thumbnail0.baidupcs.com/thumbnail/1037a4bf7t012a0828b0114dd4d0bd86?chkbd=0&chkv=0&dp-callid=0&dp-logid=3919680075957241733&expires=8h&fid=1653526243-250528-691441786604887&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-Xdm1Soq2L4ziv6zxobqbQd5VSGs%3D&size=c1080_u1080&time=1766300400&vuk=1653526243)

数组是指存储了多个字符串的数据结构。在访问数组时，需要了解如何访问其中的多个字符串。执行程序时若未初始化数组，则不会显示任何内容。我们可以通过添加内容来观察数组的变化。argc参数表示传入参数的数量，而argv是一个字符串数组，直接打印时显示的是地址信息。访问argv数组中的字符串时，索引从0开始，argv[0]表示第一个字符串，argv[1]表示第二个字符串。

﻿

11:07

﻿

- ![](https://thumbnail0.baidupcs.com/thumbnail/cae0e1c89l571acb36df3b85ee7310e1?chkbd=0&chkv=0&dp-callid=0&dp-logid=3919680164591342735&expires=8h&fid=1653526243-250528-286307879828291&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-Khd36yCKItI3ozB%2FFYj%2FRz67eC0%3D&size=c1080_u1080&time=1766300400&vuk=1653526243)访问方式：
    - 通过数组下标访问，argv[0]始终是程序完整路径
    - 用户参数从argv[1]开始存储
    - 示例：argv[1]获取第一个用户参数
- 传递示例﻿02:58﻿
    - ![](https://thumbnail0.baidupcs.com/thumbnail/8a846ab7bh50e6e78081f4082b56c8ca?chkbd=0&chkv=0&dp-callid=0&dp-logid=3919680240311482526&expires=8h&fid=1653526243-250528-1019299375755245&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-CBnTkXFgTMb7wMvUKPwe1CIT88Q%3D&size=c1080_u1080&time=1766300400&vuk=1653526243)
    - 安全访问：
    - 参数边界：
        - 未传参时直接访问argv[1]会导致内存溢出
        - 建议先判断argc值再访问对应参数
- 控制台示例﻿03:21﻿
    - ![](https://thumbnail0.baidupcs.com/thumbnail/370a7973arf4571588022414ca32b70d?chkbd=0&chkv=0&dp-callid=0&dp-logid=3919680317136213753&expires=8h&fid=1653526243-250528-1030607719988604&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-MuHa4f5iZ%2FLi7HrLfxNHLoel2Rk%3D&size=c1080_u1080&time=1766300400&vuk=1653526243)
    - 两种测试方法：
        - 控制台执行：
        - VS调试设置：
            - 项目属性→调试→命令参数填入debug info
	            - 需选择"所有配置"和"所有平台"
    - 参数解析：
        - 示例输出：

#### 二、知识小结

|   |   |   |   |
|---|---|---|---|
|知识点|核心内容|考试重点/易混淆点|难度系数|
|main函数参数传递|main函数作为程序入口可接收命令行参数，用于外部程序调用时传递实际内容|argc表示参数个数（包含程序名本身），argv是字符串数组存储具体参数|★★☆☆☆|
|参数传递方式|1. 控制台直接传递; 2. VS调试设置传递（项目属性→调试→命令参数）|数组下标从0开始：argv[0]是程序路径，用户参数从argv[1]开始|★★★☆☆|
|参数安全访问|必须通过argc判断参数数量（argc>1才可访问argv[1]）|未传参时访问argv[1]会导致内存溢出崩溃|★★★★☆|
|实际应用场景|音视频批处理时传递编码参数（比数据库/网络/文件更简洁的方案）|适合中小数据量传递，大数据可传文件路径|★★☆☆☆|
|跨平台差异|Windows直接执行程序名，Linux/macOS需加./前缀|参数分隔规则：空格作为分隔符|★★☆☆☆|
总结：
##### 一、核心职责差异（最根本区别）

`argc` 和 `argv` 是配套处理命令行参数的，但两者的核心职责完全不同：

- 第一个参数 `argc` 只负责「统计数量」：它的唯一作用是告诉程序，命令行中一共传递了多少个参数，本质是对参数总数的计数，不涉及任何具体的参数内容；
- 第二个参数 `argv` 只负责「存储内容」：它的作用是保存每一个命令行参数的具体字符串值，能让程序获取到每个参数的实际内容，不负责统计参数的个数。

简单来说，`argc` 回答了 “有多少个参数” 这个问题，而 `argv` 回答了 “每个参数是什么” 这个问题。

##### 二、数据类型与形态差异

两者的存储形态和数据类型截然不同，这决定了它们的使用方式：

- 第一个参数 `argc` 是基础整型（`int` 类型）：它是一个单一的整数变量，没有下标、没有层级，直接通过变量名就能访问到它的值，比如代码中直接写 `argc` 即可获取参数总数；
- 第二个参数 `argv` 是字符指针数组（等价于 `char** argv`）：它不是单一变量，而是一个数组结构，数组中的每个元素都是一个字符指针，指向一个字符串（对应一个命令行参数），无法直接访问整个 `argv`，需要通过数组下标（如 `argv[0]`、`argv[1]`）来获取具体的参数内容。

##### 三、取值与访问特点差异

两者的取值规则和访问方式有明显区别：

- 对于 `argc`：它的取值是整数，且有固定的最小值 1（即使没有手动传递任何参数，程序自身的路径 / 名称也会被算作一个参数，因此 `argc` 不会为 0）；当手动传递 N 个参数时，`argc` 的值就是 N+1（程序名 + N 个手动参数），它的访问无需任何判断（直接访问变量名即可），且值是固定的（由操作系统初始化后不可修改）。
- 对于 `argv`：它的取值是一组字符串，其中 `argv[0]` 是固定的（存储程序的路径或可执行文件名称，无需用户传递），`argv[1]` 及以后的元素对应用户手动传递的参数（无手动传参时，这些元素不存在）；访问它时必须依赖 `argc` 做判断（比如用 `if (argc > 1)` 判断 `argv[1]` 是否存在），否则会出现数组越界错误，且它的有效访问范围是 `0` 到 `argc-1`，`argv[argc]` 固定为 `NULL`，作为数组的结束标志。

##### 四、核心作用差异

两者在程序中的实际用途各不相同，且相互依赖：

- `argc` 的核心作用是「安全保障」：它的存在是为了限制 `argv` 的访问范围，避免程序访问 `argv` 时出现数组越界。比如你的代码中，通过 `argc > 1` 判断是否存在第一个手动参数，通过 `argc > 2` 判断是否存在第二个手动参数，这都是依赖 `argc` 来实现安全访问；
- `argv` 的核心作用是「提供数据」：它是程序获取命令行参数具体内容的唯一途径，程序的业务逻辑（比如根据用户传递的参数执行不同操作）都需要依赖 `argv` 获取实际数据，若没有 `argv`，`argc` 的计数便失去了实际意义。

##### 五、具体场景示例（直观理解差异）

比如在命令行执行 `test.exe hello world`：

- `argc` 的值是 3（程序名 `test.exe` + 手动参数 `hello` + 手动参数 `world`，共 3 个参数），它只是一个整数 3，用来告知程序 `argv` 的有效下标是 0、1、2；
- `argv` 是一个数组，`argv[0]` 指向字符串 `"test.exe"`，`argv[1]` 指向字符串 `"hello"`，`argv[2]` 指向字符串 `"world"`，程序通过这些下标才能获取到具体的参数内容，而这一切的安全访问，都依赖 `argc=3` 这个计数来约束。

再比如无手动传参时，执行 `test.exe`：

- `argc` 的值是 1，告知程序 `argv` 只有 `argv[0]` 一个有效元素；
- `argv` 只有 `argv[0]` 有效（存储 `"test.exe"`），`argv[1]` 及以后无意义，此时通过 `argc>1` 的判断，就能避免访问 `argv[1]` 导致的越界错误。

##### 总结

1. 核心区别：`argc` 是整型参数计数（管 “个数”），`argv` 是字符指针数组（管 “内容”）；
2. 形态区别：`argc` 是单一整数变量，`argv` 是数组结构，需通过下标访问；
3. 访问区别：`argc` 可直接访问，`argv` 需依赖 `argc` 判断避免越界；
4. 作用区别：`argc` 提供安全保障，`argv` 提供实际参数数据，两者配套使用实现命令行参数的处理。